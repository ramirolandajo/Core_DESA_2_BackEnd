spring.application.name=${SPRING_APPLICATION_NAME:core}


# Configuracion de Kafka
spring.kafka.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
spring.kafka.consumer.group-id=${SPRING_KAFKA_CONSUMER_GROUP_ID:analytics-mock-group}
spring.kafka.consumer.auto-offset-reset=${SPRING_KAFKA_CONSUMER_AUTO_OFFSET_RESET:earliest}
spring.kafka.consumer.enable-auto-commit=${SPRING_KAFKA_CONSUMER_ENABLE_AUTO_COMMIT:true}
spring.kafka.producer.key-serializer=${SPRING_KAFKA_PRODUCER_KEY_SERIALIZER:org.apache.kafka.common.serialization.StringSerializer}
spring.kafka.producer.value-serializer=${SPRING_KAFKA_PRODUCER_VALUE_SERIALIZER:org.springframework.kafka.support.serializer.JsonSerializer}
spring.kafka.consumer.key-deserializer=${SPRING_KAFKA_CONSUMER_KEY_DESERIALIZER:org.apache.kafka.common.serialization.StringDeserializer}
spring.kafka.consumer.value-deserializer=${SPRING_KAFKA_CONSUMER_VALUE_DESERIALIZER:org.springframework.kafka.support.serializer.JsonDeserializer}
spring.kafka.consumer.properties.spring.json.trusted.packages=${SPRING_KAFKA_CONSUMER_TRUSTED_PACKAGES:*}
# Fail-fast del admin para no quedarse reintentando infinito
spring.kafka.admin.fail-fast=${SPRING_KAFKA_ADMIN_FAIL_FAST:true}
# Reducir reintentos internos y bajar timeouts
spring.kafka.properties.retries=${SPRING_KAFKA_PROPERTIES_RETRIES:0}
spring.kafka.admin.properties.request.timeout.ms=${SPRING_KAFKA_ADMIN_PROPERTIES_REQUEST_TIMEOUT_MS:5000}
spring.kafka.properties.request.timeout.ms=${SPRING_KAFKA_PROPERTIES_REQUEST_TIMEOUT_MS:5000}

server.servlet.context-path=${SERVER_SERVLET_CONTEXT_PATH:/api}

# JPA / Hibernate
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.dialect=${SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT:org.hibernate.dialect.H2Dialect}
spring.jpa.properties.hibernate.format_sql=${SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL:true}

# =====================
# Datasource - H2 (dev rápido)
# =====================
# Comentado MySQL original
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:mysql://d2-develop.ct6ouwkcg80y.sa-east-1.rds.amazonaws.com/core_dev}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:admin}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:Desarrollo2%}
spring.datasource.driver-class-name=${SPRING_DATASOURCE_DRIVER_CLASS_NAME:com.mysql.cj.jdbc.Driver}

# H2 en memoria - modo MySQL para mayor compatibilidad de SQL
# spring.datasource.url=jdbc:h2:mem:coredb;DB_CLOSE_DELAY=-1;MODE=MySQL;DATABASE_TO_UPPER=false;IGNORECASE=TRUE
# spring.datasource.username=sa
# spring.datasource.password=
# spring.datasource.driver-class-name=org.h2.Driver

# Consola H2
spring.h2.console.enabled=${SPRING_H2_CONSOLE_ENABLED:true}
spring.h2.console.path=${SPRING_H2_CONSOLE_PATH:/h2-console}

# Asegura que el schema se cree antes de correr data.sql si existiera
spring.jpa.defer-datasource-initialization=${SPRING_JPA_DEFER_DATASOURCE_INITIALIZATION:true}

# Puerto
server.port=${SERVER_PORT:8082}

# Tópicos por módulo
app.kafka.topic.ventas=${APP_KAFKA_TOPIC_VENTAS:ventas}
app.kafka.topic.inventario=${APP_KAFKA_TOPIC_INVENTARIO:inventario}
app.kafka.topic.notificar=${APP_KAFKA_TOPIC_NOTIFICAR:notificar}

# Verificador de conexión Kafka (3 intentos, 1s entre intentos)
app.kafka.startup.max-attempts=${APP_KAFKA_STARTUP_MAX_ATTEMPTS:3}
app.kafka.startup.backoff-ms=${APP_KAFKA_STARTUP_BACKOFF_MS:1000}
app.kafka.startup.request-timeout-ms=${APP_KAFKA_STARTUP_REQUEST_TIMEOUT_MS:5000}