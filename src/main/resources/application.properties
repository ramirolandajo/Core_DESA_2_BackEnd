spring.application.name=core

# Desactivar restart de DevTools para evitar bucles de reinicio si falla el arranque
spring.devtools.restart.enabled=false

# Configuracion de Kafka
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP:ec2-18-230-11-29.sa-east-1.compute.amazonaws.com:19092}

# --- Force SASL on the AdminClient (used at startup) ---
spring.kafka.admin.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.admin.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.admin.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

# --- Force SASL on the Producer ---
spring.kafka.producer.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.producer.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.producer.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

# --- Force SASL on the Consumer ---
spring.kafka.consumer.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.consumer.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.consumer.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

spring.kafka.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

spring.kafka.consumer.group-id=analytics-mock-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*
# Fail-fast del admin para no quedarse reintentando infinito
spring.kafka.admin.fail-fast=false
spring.kafka.admin.fatal-if-broker-not-available=false
# Reducir reintentos internos y bajar timeouts
spring.kafka.properties.retries=3
spring.kafka.admin.properties.request.timeout.ms=5000
spring.kafka.properties.request.timeout.ms=5000
# Productor: cortar bloqueos largos (por ejemplo cuando no hay metadata)
spring.kafka.producer.properties.max.block.ms=5000
spring.kafka.producer.properties.delivery.timeout.ms=5000

server.servlet.context-path=/api

# =====================
# JPA / Hibernate
# =====================
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# Forzamos dialecto MySQL (no H2)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.format_sql=true

# =====================
# Datasource - SOLO MySQL Producción (RDS)
# =====================
# NOTA: mantener SOLAMENTE estas propiedades activas. Todo lo demás (H2 u otras URLs) queda comentado.
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Pool Hikari (opcional, valores conservadores para evitar "Too many connections" en dev)
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.connection-timeout=30000

# Asegura que el schema se cree antes de correr data.sql si existiera
spring.jpa.defer-datasource-initialization=true

# =====================
# Datasource - H2 (DEV) - COMENTADO
# =====================
# spring.datasource.url=jdbc:h2:mem:coredb;DB_CLOSE_DELAY=-1;MODE=MySQL;DATABASE_TO_UPPER=false;IGNORECASE=TRUE
# spring.datasource.username=sa
# spring.datasource.password=
# spring.datasource.driver-class-name=org.h2.Driver
# spring.h2.console.enabled=${SPRING_H2_CONSOLE_ENABLED:true}
# spring.h2.console.path=${SPRING_H2_CONSOLE_PATH:/h2-console}
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# Puerto
server.port=${SERVER_PORT:8082}

# Tópicos por módulo
app.kafka.topic.ventas=ventas
app.kafka.topic.inventario=inventario
app.kafka.topic.notificar=notificar

# Verificador de conexión Kafka (3 intentos, 1s entre intentos)
app.kafka.startup.max-attempts=3
app.kafka.startup.backoff-ms=1000
app.kafka.startup.request-timeout-ms=5000

# Envio a Kafka (reintentos en runtime)
app.kafka.send.max-attempts=3
app.kafka.send.backoff-ms=500
app.kafka.send.timeout-ms=5000
