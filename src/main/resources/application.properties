spring.application.name=${SPRING_APPLICATION_NAME:core}

# Desactivar restart de DevTools para evitar bucles de reinicio si falla el arranque
spring.devtools.restart.enabled=false

# Configuracion de Kafka
spring.kafka.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS}
spring.kafka.consumer.group-id=${SPRING_KAFKA_CONSUMER_GROUP_ID:analytics-mock-group}
spring.kafka.consumer.auto-offset-reset=${SPRING_KAFKA_CONSUMER_AUTO_OFFSET_RESET:earliest}
spring.kafka.consumer.enable-auto-commit=${SPRING_KAFKA_CONSUMER_ENABLE_AUTO_COMMIT:true}
spring.kafka.producer.key-serializer=${SPRING_KAFKA_PRODUCER_KEY_SERIALIZER:org.apache.kafka.common.serialization.StringSerializer}
spring.kafka.producer.value-serializer=${SPRING_KAFKA_PRODUCER_VALUE_SERIALIZER:org.springframework.kafka.support.serializer.JsonSerializer}
spring.kafka.consumer.key-deserializer=${SPRING_KAFKA_CONSUMER_KEY_DESERIALIZER:org.apache.kafka.common.serialization.StringDeserializer}
spring.kafka.consumer.value-deserializer=${SPRING_KAFKA_CONSUMER_VALUE_DESERIALIZER:org.springframework.kafka.support.serializer.JsonDeserializer}
spring.kafka.consumer.properties.spring.json.trusted.packages=${SPRING_KAFKA_CONSUMER_TRUSTED_PACKAGES:*}
# Fail-fast del admin para no quedarse reintentando infinito
spring.kafka.admin.fail-fast=${SPRING_KAFKA_ADMIN_FAIL_FAST:true}
spring.kafka.admin.fatal-if-broker-not-available=${SPRING_KAFKA_ADMIN_FATAL_IF_BROKER_NOT_AVAILABLE:true}
# Reducir reintentos internos y bajar timeouts
spring.kafka.properties.retries=${SPRING_KAFKA_PROPERTIES_RETRIES:0}
spring.kafka.admin.properties.request.timeout.ms=${SPRING_KAFKA_ADMIN_PROPERTIES_REQUEST_TIMEOUT_MS:5000}
spring.kafka.properties.request.timeout.ms=${SPRING_KAFKA_PROPERTIES_REQUEST_TIMEOUT_MS:5000}
# Productor: cortar bloqueos largos (por ejemplo cuando no hay metadata)
spring.kafka.producer.properties.max.block.ms=${SPRING_KAFKA_PRODUCER_PROPERTIES_MAX_BLOCK_MS:5000}
spring.kafka.producer.properties.delivery.timeout.ms=${SPRING_KAFKA_PRODUCER_PROPERTIES_DELIVERY_TIMEOUT_MS:5000}

server.servlet.context-path=${SERVER_SERVLET_CONTEXT_PATH:/api}

# =====================
# JPA / Hibernate
# =====================
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}
# Forzamos dialecto MySQL (no H2)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.format_sql=${SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL:true}

# =====================
# Datasource - SOLO MySQL Producción (RDS)
# =====================
# NOTA: mantener SOLAMENTE estas propiedades activas. Todo lo demás (H2 u otras URLs) queda comentado.
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Pool Hikari (opcional, valores conservadores para evitar "Too many connections" en dev)
spring.datasource.hikari.maximum-pool-size=${SPRING_DATASOURCE_HIKARI_MAX_POOL_SIZE:5}
spring.datasource.hikari.minimum-idle=${SPRING_DATASOURCE_HIKARI_MIN_IDLE:1}
spring.datasource.hikari.idle-timeout=${SPRING_DATASOURCE_HIKARI_IDLE_TIMEOUT:30000}
spring.datasource.hikari.connection-timeout=${SPRING_DATASOURCE_HIKARI_CONN_TIMEOUT:30000}

# Asegura que el schema se cree antes de correr data.sql si existiera
spring.jpa.defer-datasource-initialization=${SPRING_JPA_DEFER_DATASOURCE_INITIALIZATION:true}

# =====================
# Datasource - H2 (DEV) - COMENTADO
# =====================
# spring.datasource.url=jdbc:h2:mem:coredb;DB_CLOSE_DELAY=-1;MODE=MySQL;DATABASE_TO_UPPER=false;IGNORECASE=TRUE
# spring.datasource.username=sa
# spring.datasource.password=
# spring.datasource.driver-class-name=org.h2.Driver
# spring.h2.console.enabled=${SPRING_H2_CONSOLE_ENABLED:true}
# spring.h2.console.path=${SPRING_H2_CONSOLE_PATH:/h2-console}
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# Puerto
server.port=${SERVER_PORT:8082}

# Tópicos por módulo
app.kafka.topic.ventas=${APP_KAFKA_TOPIC_VENTAS:ventas}
app.kafka.topic.inventario=${APP_KAFKA_TOPIC_INVENTARIO:inventario}
app.kafka.topic.notificar=${APP_KAFKA_TOPIC_NOTIFICAR:notificar}

# Verificador de conexión Kafka (3 intentos, 1s entre intentos)
app.kafka.startup.max-attempts=${APP_KAFKA_STARTUP_MAX_ATTEMPTS:3}
app.kafka.startup.backoff-ms=${APP_KAFKA_STARTUP_BACKOFF_MS:1000}
app.kafka.startup.request-timeout-ms=${APP_KAFKA_STARTUP_REQUEST_TIMEOUT_MS:5000}

# Envio a Kafka (reintentos en runtime)
app.kafka.send.max-attempts=${APP_KAFKA_SEND_MAX_ATTEMPTS:3}
app.kafka.send.backoff-ms=${APP_KAFKA_SEND_BACKOFF_MS:500}
app.kafka.send.timeout-ms=${APP_KAFKA_SEND_TIMEOUT_MS:5000}
